// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: services.proto

package coopstate

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ServerClient is the client API for Server service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServerClient interface {
	FetchLevels(ctx context.Context, in *FetchLevelsRequest, opts ...grpc.CallOption) (*FetchLevelsResponse, error)
	CreateLobby(ctx context.Context, in *CreateLobbyRequest, opts ...grpc.CallOption) (*CreateLobbyResponse, error)
	FetchLobbies(ctx context.Context, in *FetchLobbiesRequest, opts ...grpc.CallOption) (*FetchLobbiesResponse, error)
	JoinLobby(ctx context.Context, in *JoinLobbyRequest, opts ...grpc.CallOption) (*JoinLobbyResponse, error)
	PutTower(ctx context.Context, in *PutTowerRequest, opts ...grpc.CallOption) (*PutTowerResponse, error)
	UpgradeTower(ctx context.Context, in *UpgradeTowerRequest, opts ...grpc.CallOption) (*UpgradeTowerResponse, error)
	TurnTowerOn(ctx context.Context, in *TurnTowerOnRequest, opts ...grpc.CallOption) (*TurnTowerOnResponse, error)
	TurnTowerOff(ctx context.Context, in *TurnTowerOffRequest, opts ...grpc.CallOption) (*TurnTowerOffResponse, error)
	ChangeTowerAimType(ctx context.Context, in *ChangeTowerAimTypeRequest, opts ...grpc.CallOption) (*ChangeTowerAimTypeResponse, error)
	SellTower(ctx context.Context, in *SellTowerRequest, opts ...grpc.CallOption) (*SellTowerResponse, error)
	StartNewWave(ctx context.Context, in *StartNewWaveRequest, opts ...grpc.CallOption) (*StartNewWaveResponse, error)
	SlowGameDown(ctx context.Context, in *SlowGameDownRequest, opts ...grpc.CallOption) (*SlowGameDownResponse, error)
	SpeedGameUp(ctx context.Context, in *SpeedGameUpRequest, opts ...grpc.CallOption) (*SpeedGameUpResponse, error)
	LeaveLobby(ctx context.Context, in *LeaveLobbyRequest, opts ...grpc.CallOption) (*LeaveLobbyResponse, error)
}

type serverClient struct {
	cc grpc.ClientConnInterface
}

func NewServerClient(cc grpc.ClientConnInterface) ServerClient {
	return &serverClient{cc}
}

func (c *serverClient) FetchLevels(ctx context.Context, in *FetchLevelsRequest, opts ...grpc.CallOption) (*FetchLevelsResponse, error) {
	out := new(FetchLevelsResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/FetchLevels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) CreateLobby(ctx context.Context, in *CreateLobbyRequest, opts ...grpc.CallOption) (*CreateLobbyResponse, error) {
	out := new(CreateLobbyResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/CreateLobby", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) FetchLobbies(ctx context.Context, in *FetchLobbiesRequest, opts ...grpc.CallOption) (*FetchLobbiesResponse, error) {
	out := new(FetchLobbiesResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/FetchLobbies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) JoinLobby(ctx context.Context, in *JoinLobbyRequest, opts ...grpc.CallOption) (*JoinLobbyResponse, error) {
	out := new(JoinLobbyResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/JoinLobby", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) PutTower(ctx context.Context, in *PutTowerRequest, opts ...grpc.CallOption) (*PutTowerResponse, error) {
	out := new(PutTowerResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/PutTower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) UpgradeTower(ctx context.Context, in *UpgradeTowerRequest, opts ...grpc.CallOption) (*UpgradeTowerResponse, error) {
	out := new(UpgradeTowerResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/UpgradeTower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) TurnTowerOn(ctx context.Context, in *TurnTowerOnRequest, opts ...grpc.CallOption) (*TurnTowerOnResponse, error) {
	out := new(TurnTowerOnResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/TurnTowerOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) TurnTowerOff(ctx context.Context, in *TurnTowerOffRequest, opts ...grpc.CallOption) (*TurnTowerOffResponse, error) {
	out := new(TurnTowerOffResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/TurnTowerOff", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) ChangeTowerAimType(ctx context.Context, in *ChangeTowerAimTypeRequest, opts ...grpc.CallOption) (*ChangeTowerAimTypeResponse, error) {
	out := new(ChangeTowerAimTypeResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/ChangeTowerAimType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SellTower(ctx context.Context, in *SellTowerRequest, opts ...grpc.CallOption) (*SellTowerResponse, error) {
	out := new(SellTowerResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/SellTower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) StartNewWave(ctx context.Context, in *StartNewWaveRequest, opts ...grpc.CallOption) (*StartNewWaveResponse, error) {
	out := new(StartNewWaveResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/StartNewWave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SlowGameDown(ctx context.Context, in *SlowGameDownRequest, opts ...grpc.CallOption) (*SlowGameDownResponse, error) {
	out := new(SlowGameDownResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/SlowGameDown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SpeedGameUp(ctx context.Context, in *SpeedGameUpRequest, opts ...grpc.CallOption) (*SpeedGameUpResponse, error) {
	out := new(SpeedGameUpResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/SpeedGameUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) LeaveLobby(ctx context.Context, in *LeaveLobbyRequest, opts ...grpc.CallOption) (*LeaveLobbyResponse, error) {
	out := new(LeaveLobbyResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Server/LeaveLobby", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServerServer is the server API for Server service.
// All implementations must embed UnimplementedServerServer
// for forward compatibility
type ServerServer interface {
	FetchLevels(context.Context, *FetchLevelsRequest) (*FetchLevelsResponse, error)
	CreateLobby(context.Context, *CreateLobbyRequest) (*CreateLobbyResponse, error)
	FetchLobbies(context.Context, *FetchLobbiesRequest) (*FetchLobbiesResponse, error)
	JoinLobby(context.Context, *JoinLobbyRequest) (*JoinLobbyResponse, error)
	PutTower(context.Context, *PutTowerRequest) (*PutTowerResponse, error)
	UpgradeTower(context.Context, *UpgradeTowerRequest) (*UpgradeTowerResponse, error)
	TurnTowerOn(context.Context, *TurnTowerOnRequest) (*TurnTowerOnResponse, error)
	TurnTowerOff(context.Context, *TurnTowerOffRequest) (*TurnTowerOffResponse, error)
	ChangeTowerAimType(context.Context, *ChangeTowerAimTypeRequest) (*ChangeTowerAimTypeResponse, error)
	SellTower(context.Context, *SellTowerRequest) (*SellTowerResponse, error)
	StartNewWave(context.Context, *StartNewWaveRequest) (*StartNewWaveResponse, error)
	SlowGameDown(context.Context, *SlowGameDownRequest) (*SlowGameDownResponse, error)
	SpeedGameUp(context.Context, *SpeedGameUpRequest) (*SpeedGameUpResponse, error)
	LeaveLobby(context.Context, *LeaveLobbyRequest) (*LeaveLobbyResponse, error)
	mustEmbedUnimplementedServerServer()
}

// UnimplementedServerServer must be embedded to have forward compatible implementations.
type UnimplementedServerServer struct {
}

func (UnimplementedServerServer) FetchLevels(context.Context, *FetchLevelsRequest) (*FetchLevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchLevels not implemented")
}
func (UnimplementedServerServer) CreateLobby(context.Context, *CreateLobbyRequest) (*CreateLobbyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLobby not implemented")
}
func (UnimplementedServerServer) FetchLobbies(context.Context, *FetchLobbiesRequest) (*FetchLobbiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchLobbies not implemented")
}
func (UnimplementedServerServer) JoinLobby(context.Context, *JoinLobbyRequest) (*JoinLobbyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinLobby not implemented")
}
func (UnimplementedServerServer) PutTower(context.Context, *PutTowerRequest) (*PutTowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutTower not implemented")
}
func (UnimplementedServerServer) UpgradeTower(context.Context, *UpgradeTowerRequest) (*UpgradeTowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgradeTower not implemented")
}
func (UnimplementedServerServer) TurnTowerOn(context.Context, *TurnTowerOnRequest) (*TurnTowerOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TurnTowerOn not implemented")
}
func (UnimplementedServerServer) TurnTowerOff(context.Context, *TurnTowerOffRequest) (*TurnTowerOffResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TurnTowerOff not implemented")
}
func (UnimplementedServerServer) ChangeTowerAimType(context.Context, *ChangeTowerAimTypeRequest) (*ChangeTowerAimTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTowerAimType not implemented")
}
func (UnimplementedServerServer) SellTower(context.Context, *SellTowerRequest) (*SellTowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellTower not implemented")
}
func (UnimplementedServerServer) StartNewWave(context.Context, *StartNewWaveRequest) (*StartNewWaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartNewWave not implemented")
}
func (UnimplementedServerServer) SlowGameDown(context.Context, *SlowGameDownRequest) (*SlowGameDownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SlowGameDown not implemented")
}
func (UnimplementedServerServer) SpeedGameUp(context.Context, *SpeedGameUpRequest) (*SpeedGameUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpeedGameUp not implemented")
}
func (UnimplementedServerServer) LeaveLobby(context.Context, *LeaveLobbyRequest) (*LeaveLobbyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveLobby not implemented")
}
func (UnimplementedServerServer) mustEmbedUnimplementedServerServer() {}

// UnsafeServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServerServer will
// result in compilation errors.
type UnsafeServerServer interface {
	mustEmbedUnimplementedServerServer()
}

func RegisterServerServer(s grpc.ServiceRegistrar, srv ServerServer) {
	s.RegisterService(&Server_ServiceDesc, srv)
}

func _Server_FetchLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).FetchLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/FetchLevels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).FetchLevels(ctx, req.(*FetchLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_CreateLobby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLobbyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).CreateLobby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/CreateLobby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).CreateLobby(ctx, req.(*CreateLobbyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_FetchLobbies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchLobbiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).FetchLobbies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/FetchLobbies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).FetchLobbies(ctx, req.(*FetchLobbiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_JoinLobby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinLobbyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).JoinLobby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/JoinLobby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).JoinLobby(ctx, req.(*JoinLobbyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_PutTower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutTowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).PutTower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/PutTower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).PutTower(ctx, req.(*PutTowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_UpgradeTower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeTowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).UpgradeTower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/UpgradeTower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).UpgradeTower(ctx, req.(*UpgradeTowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_TurnTowerOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TurnTowerOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).TurnTowerOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/TurnTowerOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).TurnTowerOn(ctx, req.(*TurnTowerOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_TurnTowerOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TurnTowerOffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).TurnTowerOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/TurnTowerOff",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).TurnTowerOff(ctx, req.(*TurnTowerOffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_ChangeTowerAimType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeTowerAimTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).ChangeTowerAimType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/ChangeTowerAimType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).ChangeTowerAimType(ctx, req.(*ChangeTowerAimTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SellTower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellTowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SellTower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/SellTower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SellTower(ctx, req.(*SellTowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_StartNewWave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartNewWaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).StartNewWave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/StartNewWave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).StartNewWave(ctx, req.(*StartNewWaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SlowGameDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlowGameDownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SlowGameDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/SlowGameDown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SlowGameDown(ctx, req.(*SlowGameDownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SpeedGameUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpeedGameUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SpeedGameUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/SpeedGameUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SpeedGameUp(ctx, req.(*SpeedGameUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_LeaveLobby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveLobbyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).LeaveLobby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Server/LeaveLobby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).LeaveLobby(ctx, req.(*LeaveLobbyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Server_ServiceDesc is the grpc.ServiceDesc for Server service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Server_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "td_game.coopstate.Server",
	HandlerType: (*ServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchLevels",
			Handler:    _Server_FetchLevels_Handler,
		},
		{
			MethodName: "CreateLobby",
			Handler:    _Server_CreateLobby_Handler,
		},
		{
			MethodName: "FetchLobbies",
			Handler:    _Server_FetchLobbies_Handler,
		},
		{
			MethodName: "JoinLobby",
			Handler:    _Server_JoinLobby_Handler,
		},
		{
			MethodName: "PutTower",
			Handler:    _Server_PutTower_Handler,
		},
		{
			MethodName: "UpgradeTower",
			Handler:    _Server_UpgradeTower_Handler,
		},
		{
			MethodName: "TurnTowerOn",
			Handler:    _Server_TurnTowerOn_Handler,
		},
		{
			MethodName: "TurnTowerOff",
			Handler:    _Server_TurnTowerOff_Handler,
		},
		{
			MethodName: "ChangeTowerAimType",
			Handler:    _Server_ChangeTowerAimType_Handler,
		},
		{
			MethodName: "SellTower",
			Handler:    _Server_SellTower_Handler,
		},
		{
			MethodName: "StartNewWave",
			Handler:    _Server_StartNewWave_Handler,
		},
		{
			MethodName: "SlowGameDown",
			Handler:    _Server_SlowGameDown_Handler,
		},
		{
			MethodName: "SpeedGameUp",
			Handler:    _Server_SpeedGameUp_Handler,
		},
		{
			MethodName: "LeaveLobby",
			Handler:    _Server_LeaveLobby_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ClientClient is the client API for Client service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClientClient interface {
	LobbyFilledGameStarted(ctx context.Context, in *LobbyFilledGameStartedRequest, opts ...grpc.CallOption) (*LobbyFilledGameStartedResponse, error)
	SendGameState(ctx context.Context, opts ...grpc.CallOption) (Client_SendGameStateClient, error)
}

type clientClient struct {
	cc grpc.ClientConnInterface
}

func NewClientClient(cc grpc.ClientConnInterface) ClientClient {
	return &clientClient{cc}
}

func (c *clientClient) LobbyFilledGameStarted(ctx context.Context, in *LobbyFilledGameStartedRequest, opts ...grpc.CallOption) (*LobbyFilledGameStartedResponse, error) {
	out := new(LobbyFilledGameStartedResponse)
	err := c.cc.Invoke(ctx, "/td_game.coopstate.Client/LobbyFilledGameStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientClient) SendGameState(ctx context.Context, opts ...grpc.CallOption) (Client_SendGameStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Client_ServiceDesc.Streams[0], "/td_game.coopstate.Client/SendGameState", opts...)
	if err != nil {
		return nil, err
	}
	x := &clientSendGameStateClient{stream}
	return x, nil
}

type Client_SendGameStateClient interface {
	Send(*SendGameStateRequest) error
	CloseAndRecv() (*SendGameStateResponse, error)
	grpc.ClientStream
}

type clientSendGameStateClient struct {
	grpc.ClientStream
}

func (x *clientSendGameStateClient) Send(m *SendGameStateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *clientSendGameStateClient) CloseAndRecv() (*SendGameStateResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SendGameStateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClientServer is the server API for Client service.
// All implementations must embed UnimplementedClientServer
// for forward compatibility
type ClientServer interface {
	LobbyFilledGameStarted(context.Context, *LobbyFilledGameStartedRequest) (*LobbyFilledGameStartedResponse, error)
	SendGameState(Client_SendGameStateServer) error
	mustEmbedUnimplementedClientServer()
}

// UnimplementedClientServer must be embedded to have forward compatible implementations.
type UnimplementedClientServer struct {
}

func (UnimplementedClientServer) LobbyFilledGameStarted(context.Context, *LobbyFilledGameStartedRequest) (*LobbyFilledGameStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyFilledGameStarted not implemented")
}
func (UnimplementedClientServer) SendGameState(Client_SendGameStateServer) error {
	return status.Errorf(codes.Unimplemented, "method SendGameState not implemented")
}
func (UnimplementedClientServer) mustEmbedUnimplementedClientServer() {}

// UnsafeClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClientServer will
// result in compilation errors.
type UnsafeClientServer interface {
	mustEmbedUnimplementedClientServer()
}

func RegisterClientServer(s grpc.ServiceRegistrar, srv ClientServer) {
	s.RegisterService(&Client_ServiceDesc, srv)
}

func _Client_LobbyFilledGameStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LobbyFilledGameStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServer).LobbyFilledGameStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/td_game.coopstate.Client/LobbyFilledGameStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServer).LobbyFilledGameStarted(ctx, req.(*LobbyFilledGameStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client_SendGameState_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ClientServer).SendGameState(&clientSendGameStateServer{stream})
}

type Client_SendGameStateServer interface {
	SendAndClose(*SendGameStateResponse) error
	Recv() (*SendGameStateRequest, error)
	grpc.ServerStream
}

type clientSendGameStateServer struct {
	grpc.ServerStream
}

func (x *clientSendGameStateServer) SendAndClose(m *SendGameStateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *clientSendGameStateServer) Recv() (*SendGameStateRequest, error) {
	m := new(SendGameStateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client_ServiceDesc is the grpc.ServiceDesc for Client service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Client_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "td_game.coopstate.Client",
	HandlerType: (*ClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LobbyFilledGameStarted",
			Handler:    _Client_LobbyFilledGameStarted_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendGameState",
			Handler:       _Client_SendGameState_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "services.proto",
}
